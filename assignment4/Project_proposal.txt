Implementing Regression Test Selection for Android Applications
Yuankai Yue, Kai Chih Chang, Xiong Zheng

Smartphones are becoming pervasive, with more than 670 million sold worldwide in the first half of year 2016. One of the major advantages of having a smartphone is its ability to run applications. This trend, in turn,  leads to the significant increase of the number of mobile applications being developed for various platforms. Because most mobile applications are developed in quick succession with concentration mostly in their functionality, an efficient and effective software testing scheme becomes particularly important to ensure the reliability of the application. In this project, we will implement a regression test selection approach for Android application based on a recently developed tool, known as Redroid (1). Building upon this tool, we will use a different method level dependencies collection scheme, and explore its real world practicality.  

Regression testing is a necessary but expensive testing technique performed during each iteration of application revisions. But as the size of test suite increases with evolution of the application, the execution of the entire test suite can sometimes be very costly. To maximize the benefit of regression testing, extensive researches have been done in three main directions, namely the minimization, selection and prioritization of the test suite. For test suite minimization, the goal is to eliminate the number of redundant tests in the test suite, while test suite selection focus more on achieving coverage of code changes with selected tests. On the other hand, test suite prioritization seek to order test for early fault detection. (2)

Regression test selection (RTS), as one technique of regression testing, chooses tests from an existing test pool if the test is relevant to the changes between the previous and the current version of software. Many approaches of the RTS have been studied, such as graphic walk approach, program slicing based approach, and etc. one example of graphic walk approach is named the dejavu algorithm, which is based on the use control flow graphs (CFGs). In this algorithm, two CFGs are constructed for the original and modified version of the application. The nodes in the graph represent statements in the application, while the edges represent the the flow of the execution. By doing a pairwise traversal of the CFG of the original and modified application, the modified edges can be identified. Then the algorithm will select all tests that covers those edges. (3)

Dynamic program slicing is another example of RTS. It is based on the fact that an execution slice of the test case can contain statements that do not affect the output statement, like an integer assignment, which is later overwritten before being invoked by any function. By recursively traversing the dynamic dependency graph of the program for a given test case, dynamic program slicing determines for each test case the statements that have an effect on the program output, therefore relevant test cases can be further identified. Building upon this idea, different slicing criteria can be imposed, to make the slicing more precise. (4)

However, mobile application is quite different from a traditional application, as it has limited resources (like performance and energy source), a wider range of connectivity, new programming (runtime) environment and event centric structures. Therefore, even though regression testing has been extensively studied for traditional applications, many effective and efficient approaches described above can not be directly adopted to mobile applications. 

In an attempt to bridge the gap of application testing between mobile application and traditional desktop application, we propose to implement a RTS tool in this project that uses dynamic dependency analyzer to collect method dependencies and test case coverage information at the same time, and then use these information to aid test case selection. We are going to divide this project into three logical parts.

First, implement a dependency analyzer that can detect the changes between the original application and its modified version. Since Android applications are developed using Dalvik Virtual Machine rather than the Oracle Java Virtual Machine, we will use the ASMDEX library to dynamically instrument code and collect method dependencies. The algorithm we will use to achieve dynamic dependency collection is adopted from EKSTAZI, a recently developed RTS technique. EKSTAZI checks the change of an application by tracking the dynamic dependency of test cases on files (including directories). However, because most android applications have a relatively small number of class files, but rather larger number of methods in one class, we will modify the dependency collection technique to work with methods, rather than files.  Instrumented test cases will use checksums of all used methods from the application under test to track the changes between original and modified version (5). The “by-product” of instrumenting test cases is that the test coverage is also automatically generated during the process. This method is significantly different from the control-flow graph based Dejavu algorithm that is implemented in the Redroid tool. Being a static dependency collection method, Redroid requires a subsequent coverage generation step to complement the test selection process.

Second, implement a test case selector that uses the information provided by the dependency analyzer select test cases for re-execution. During the execution of selected tests, new dependency files will be created  and save for the test cases. As the selected test should execute the change in the modified code, different behavior of the test can be expected. 

Finally, we will test this tool on a android emulator with open source android applications, and then successively move to an Android smartphone. The result will be quantified in the final report.

References:
(1). http://dl.acm.org/citation.cfm?id=2897127
(2). http://dl.acm.org/citation.cfm?id=2284813
(3). http://dl.acm.org/citation.cfm?id=248262
(4). http://dl.acm.org/citation.cfm?id=658149
(5). http://dl.acm.org/citation.cfm?id=2771784


